<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/database-transaction.js | electron-RxDB API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-change-record.js~DatabaseChangeRecord.html">DatabaseChangeRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-transaction.js~DatabaseTransaction.html">DatabaseTransaction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/json-blob.js~JSONBlob.html">JSONBlob</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mutable-query-result-set.js~MutableQueryResultSet.html">MutableQueryResultSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mutable-query-subscription.js~MutableQuerySubscription.html">MutableQuerySubscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-range.js~QueryRange.html">QueryRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-result-set.js~QueryResultSet.html">QueryResultSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-subscription.js~QuerySubscription.html">QuerySubscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query.js~ModelQuery.html">ModelQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/rx-database.js~RxDatabase.html">RxDatabase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-logSQLString">logSQLString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateTempId">generateTempId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isTempId">isTempId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modelFreeze">modelFreeze</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tableNameForJoin">tableNameForJoin</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">attributes</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-boolean.js~AttributeBoolean.html">AttributeBoolean</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-collection.js~AttributeCollection.html">AttributeCollection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-datetime.js~AttributeDateTime.html">AttributeDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-joined-data.js~AttributeJoinedData.html">AttributeJoinedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-number.js~AttributeNumber.html">AttributeNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-object.js~AttributeObject.html">AttributeObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-string.js~AttributeString.html">AttributeString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute.js~Attribute.html">Attribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/matcher.js~Matcher.html">Matcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/sort-order.js~SortOrder.html">SortOrder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">browser</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/browser/coordinator.js~Coordinator.html">Coordinator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/database-transaction.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint global-require:0 */
/* eslint import/newline-after-import:0 */
import Model from &apos;./model&apos;;
import {tableNameForJoin} from &apos;./utils&apos;;

import Attributes from &apos;./attributes&apos;;
import DatabaseChangeRecord from &apos;./database-change-record&apos;;

require(&apos;promise.prototype.finally&apos;).shim();
require(&apos;promise.try&apos;).shim()

const {AttributeCollection, AttributeJoinedData} = Attributes;

/**
DatabaseTransaction exposes a convenient API for querying and modifying an RxDB
within a SQLite transaction.

You shouldn&apos;t need to instantiate this class directly. Instead, use
RxDatabase#inTransaction.
*/
export default class DatabaseTransaction {
  constructor(database) {
    this.database = database;
    this._changeRecords = [];
    this._opened = false;
  }

  /**
  @borrows RxDatabase#find
  */
  find(...args) { return this.database.find(...args) }
  findBy(...args) { return this.database.findBy(...args) }
  findAll(...args) { return this.database.findAll(...args) }
  modelify(...args) { return this.database.modelify(...args) }
  count(...args) { return this.database.count(...args) }
  findJSONBlob(...args) { return this.database.findJSONBlob(...args) }

  execute(fn) {
    if (this._opened) {
      throw new Error(&quot;DatabaseTransaction:execute was already called&quot;);
    }

    return this._query(&quot;BEGIN IMMEDIATE TRANSACTION&quot;).then(() =&gt; {
      this._opened = true;
      return fn(this);
    }).finally(() =&gt; {
      if (!this._opened) {
        return null;
      }
      this._opened = false;
      return this._query(&quot;COMMIT&quot;).then(() =&gt; {
        this.database.transactionDidCommitChanges(this._changeRecords);
      });
    });
  }

  // Mutating the Database

  persistJSONBlob(id, json) {
    const JSONBlob = require(&apos;./json-blob&apos;).default;
    return this.persistModel(new JSONBlob({id, json}));
  }

  /**
  Asynchronously writes `model` to the cache and triggers a change event.

  @param {Model} model - A {Model} to write to the database.

  @returns {Promise} - A promise that:
    - resolves after the database queries are complete and any listening
      database callbacks have finished
    - rejects if any databse query fails or one of the triggering
      callbacks failed
  */
  persistModel(model) {
    if (!model || !(model instanceof Model)) {
      throw new Error(&quot;DatabaseTransaction::persistModel - You must pass an instance of the Model class.&quot;);
    }
    return this.persistModels([model]);
  }

  /**
  Asynchronously writes `models` to the cache and triggers a single change
  event. Note: Models must be of the same class to be persisted in a batch operation.

  @param {Array} models - An {Array} of {Model} objects to write to the database.

  @returns {Promise} - A promise that:
    - resolves after the database queries are complete and any listening
      database callbacks have finished
    - rejects if any databse query fails or one of the triggering
      callbacks failed
  */
  persistModels(models = []) {
    if (models.length === 0) {
      return Promise.resolve();
    }

    const klass = models[0].constructor;
    const clones = [];
    const ids = {};

    if (!(models[0] instanceof Model)) {
      throw new Error(`DatabaseTransaction::persistModels - You must pass an array of items which descend from the Model class.`);
    }

    for (const model of models) {
      if (!model || (model.constructor !== klass)) {
        throw new Error(`DatabaseTransaction::persistModels - When you batch persist objects, they must be of the same type`);
      }
      if (ids[model.id]) {
        throw new Error(`DatabaseTransaction::persistModels - You must pass an array of models with different ids. ID ${model.id} is in the set multiple times.`)
      }
      clones.push(model.clone());
      ids[model.id] = true;
    }

    // Note: It&apos;s important that we clone the objects since other code could mutate
    // them during the save process. We want to guaruntee that the models you send to
    // persistModels are saved exactly as they were sent.
    const metadata = {
      objectClass: clones[0].constructor.name,
      objectIds: Object.keys(ids),
      objects: clones,
      type: &apos;persist&apos;,
    };

    return this._runMutationHooks(&apos;beforeDatabaseChange&apos;, metadata).then((data) =&gt; {
      return this._writeModels(clones).then(() =&gt; {
        this._runMutationHooks(&apos;afterDatabaseChange&apos;, metadata, data);
        return this._changeRecords.push(new DatabaseChangeRecord(this.database, metadata));
      });
    });
  }

  /**
  Asynchronously removes `model` from the cache and triggers a change event.

  @param {Model} model - A {Model} to write to the database.

  @returns {Promise} - A promise that
    - resolves after the database queries are complete and any listening
      database callbacks have finished
    - rejects if any databse query fails or one of the triggering
      callbacks failed
  */
  unpersistModel(model) {
    const clone = model.clone();
    const metadata = {
      objectClass: clone.constructor.name,
      objectIds: [clone.id],
      objects: [clone],
      type: &apos;unpersist&apos;,
    }

    return this._runMutationHooks(&apos;beforeDatabaseChange&apos;, metadata).then((data) =&gt; {
      return this._deleteModel(clone).then(() =&gt; {
        this._runMutationHooks(&apos;afterDatabaseChange&apos;, metadata, data);
        return this._changeRecords.push(new DatabaseChangeRecord(this.database, metadata));
      });
    });
  }

  // PRIVATE METHODS ////////////////////////////////////////////////////////

  _query = (...args) =&gt; {
    return this.database._query(...args);
  }

  _runMutationHooks(selectorName, metadata, data = []) {
    const beforePromises = this.database.mutationHooks().map((hook, idx) =&gt;
      Promise.try(() =&gt; hook[selectorName](this._query, metadata, data[idx]))
    );

    return Promise.all(beforePromises).catch((e) =&gt; {
      if (!process.env.CI) {
        console.warn(`DatabaseTransaction Hook: ${selectorName} failed`, e);
      }
      return Promise.resolve([]);
    });
  }

  // Fires the queries required to write models to the DB
  //
  // Returns a promise that:
  //   - resolves when all write queries are complete
  //   - rejects if any query fails
  _writeModels(models) {
    const promises = [];

    // IMPORTANT: This method assumes that all the models you
    // provide are of the same class, and have different ids!

    // Avoid trying to write too many objects a time - sqlite can only handle
    // value sets `(?,?)...` of less than SQLITE_MAX_COMPOUND_SELECT (500),
    // and we don&apos;t know ahead of time whether we&apos;ll hit that or not.
    if (models.length &gt; 50) {
      return Promise.all([
        this._writeModels(models.slice(0, 50)),
        this._writeModels(models.slice(50)),
      ]);
    }

    const klass = models[0].constructor;
    const attributes = Object.keys(klass.attributes).map(key =&gt; klass.attributes[key])

    const columnAttributes = attributes.filter((attr) =&gt;
      attr.queryable &amp;&amp; attr.columnSQL &amp;&amp; attr.jsonKey !== &apos;id&apos;
    );

    // Compute the columns in the model table and a question mark string
    const columns = [&apos;id&apos;, &apos;data&apos;];
    const columnMarks = [&apos;?&apos;, &apos;?&apos;];
    columnAttributes.forEach((attr) =&gt; {
      columns.push(attr.jsonKey);
      columnMarks.push(&apos;?&apos;);
    });
    const columnsSQL = columns.join(&apos;,&apos;);
    const marksSet = `(${columnMarks.join(&apos;,&apos;)})`;

    // Prepare a batch insert VALUES (?,?,?), (?,?,?)... by assembling
    // an array of the values and a corresponding question mark set
    const values = [];
    const marks = [];
    const ids = [];
    const modelsJSONs = [];
    for (const model of models) {
      const json = model.toJSON({joined: false});
      modelsJSONs.push(json);
      ids.push(model.id);
      values.push(model.id, JSON.stringify(json, this.database.models.JSONReplacer));
      columnAttributes.forEach((attr) =&gt; {
        values.push(json[attr.jsonKey]);
      });
      marks.push(marksSet);
    }

    const marksSQL = marks.join(&apos;,&apos;);

    promises.push(this._query(`REPLACE INTO \`${klass.name}\` (${columnsSQL}) VALUES ${marksSQL}`, values));

    // For each join table property, find all the items in the join table for this
    // model and delete them. Insert each new value back into the table.
    const collectionAttributes = attributes.filter((attr) =&gt;
      attr.queryable &amp;&amp; attr instanceof AttributeCollection
    )

    collectionAttributes.forEach((attr) =&gt; {
      const joinTable = tableNameForJoin(klass, attr.itemClass);

      promises.push(this._query(`DELETE FROM \`${joinTable}\` WHERE \`id\` IN (&apos;${ids.join(&quot;&apos;,&apos;&quot;)}&apos;)`));

      const joinMarks = [];
      const joinedValues = [];
      const joinMarkUnit = `(${[&quot;?&quot;, &quot;?&quot;].concat(attr.joinQueryableBy.map(() =&gt; &apos;?&apos;)).join(&apos;,&apos;)})`;
      const joinQueryableByJSONKeys = attr.joinQueryableBy.map(joinedModelKey =&gt;
        klass.attributes[joinedModelKey].jsonKey
      );
      const joinColumns = [&apos;id&apos;, &apos;value&apos;].concat(joinQueryableByJSONKeys);

      // https://www.sqlite.org/limits.html: SQLITE_MAX_VARIABLE_NUMBER
      const valuesPerRow = joinColumns.length;
      const rowsPerInsert = Math.floor(600 / valuesPerRow);
      const valuesPerInsert = rowsPerInsert * valuesPerRow;

      models.forEach((model, idx) =&gt; {
        const joinedModels = model[attr.modelKey] || [];
        for (const joined of joinedModels) {
          if (!attr.joinOnField) {
            throw new Error(`Queryable collection attribute ${attr.modelKey} must specify a joinOnField`);
          }
          const joinValue = joined[attr.joinOnField];
          joinMarks.push(joinMarkUnit);
          joinedValues.push(model.id, joinValue);
          for (const joinedJsonKey of joinQueryableByJSONKeys) {
            joinedValues.push(modelsJSONs[idx][joinedJsonKey]);
          }
        }
      });

      if (joinedValues.length !== 0) {
        // Write no more than 200 items (400 values) at once to avoid sqlite limits
        // 399 values: slices:[0..0]
        // 400 values: slices:[0..0]
        // 401 values: slices:[0..1]
        const slicePageCount = Math.ceil(joinMarks.length / rowsPerInsert) - 1;
        for (let slice = 0; slice &lt;= slicePageCount; slice++) {
          const [ms, me] = [slice * rowsPerInsert, slice * rowsPerInsert + rowsPerInsert];
          const [vs, ve] = [slice * valuesPerInsert, slice * valuesPerInsert + valuesPerInsert];
          promises.push(this._query(`INSERT OR IGNORE INTO \`${joinTable}\` (\`${joinColumns.join(&apos;`,`&apos;)}\`) VALUES ${joinMarks.slice(ms, me).join(&apos;,&apos;)}`, joinedValues.slice(vs, ve)));
        }
      }
    });

    // For each joined data property stored in another table...
    const joinedDataAttributes = attributes.filter(attr =&gt;
      attr instanceof AttributeJoinedData
    )

    joinedDataAttributes.forEach((attr) =&gt; {
      for (const model of models) {
        if (model[attr.modelKey] !== undefined) {
          promises.push(this._query(`REPLACE INTO \`${attr.modelTable}\` (\`id\`, \`value\`) VALUES (?, ?)`, [model.id, model[attr.modelKey]]));
        }
      }
    });

    return Promise.all(promises);
  }

  // Fires the queries required to delete models to the DB
  //
  // Returns a promise that:
  //   - resolves when all deltion queries are complete
  //   - rejects if any query fails
  _deleteModel(model) {
    const promises = []

    const klass = model.constructor;
    const attributes = Object.keys(klass.attributes).map(key =&gt; klass.attributes[key]);

    // Delete the primary record
    promises.push(this._query(`DELETE FROM \`${klass.name}\` WHERE \`id\` = ?`, [model.id]))

    // For each join table property, find all the items in the join table for this
    // model and delte them. Insert each new value back into the table.
    const collectionAttributes = attributes.filter(attr =&gt;
      attr.queryable &amp;&amp; attr instanceof AttributeCollection
    );

    collectionAttributes.forEach((attr) =&gt; {
      const joinTable = tableNameForJoin(klass, attr.itemClass);
      promises.push(this._query(`DELETE FROM \`${joinTable}\` WHERE \`id\` = ?`, [model.id]))
    });

    const joinedDataAttributes = attributes.filter(attr =&gt;
      attr instanceof AttributeJoinedData
    );

    joinedDataAttributes.forEach((attr) =&gt; {
      promises.push(this._query(`DELETE FROM \`${attr.modelTable}\` WHERE \`id\` = ?`, [model.id]));
    });

    return Promise.all(promises);
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
